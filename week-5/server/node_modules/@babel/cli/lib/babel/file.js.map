{"version":3,"names":["_convertSourceMap","data","require","_traceMapping","_slash","_path","_fs","util","watcher","asyncGeneratorStep","gen","resolve","reject","_next","_throw","key","arg","info","value","error","done","Promise","then","_asyncToGenerator","fn","self","args","arguments","apply","err","undefined","_default","_x","_ref","cliOptions","babelOptions","buildResult","fileResults","mapSections","code","offset","hasRawMap","result","map","push","line","column","version","names","sources","mappings","countNewlines","AnyMap","file","sourceMapTarget","path","basename","outFile","sections","sourceRoot","sourceMaps","convertSourceMap","fromObject","encodedMap","toComment","count","index","indexOf","output","v","w","split","process","versions","node","mkdirSync","sync","dirname","recursive","outputMap","hasDataSourcemap","mapLoc","addSourceMappingUrl","fs","writeFileSync","JSON","stringify","stdout","write","readStdin","stdin","setEncoding","on","chunk","read","_stdin","res","transformRepl","filename","Object","assign","sourceFileName","walk","_x2","_walk","filenames","_filenames","forEach","existsSync","stat","statSync","isDirectory","readdirForCompilable","includeDotfiles","extensions","join","results","all","sourceFilename","relative","slash","compile","watch","console","files","_x3","_files","enable","enableGlobbing","skipInitialBuild","startWatcher","onFilesChange","changes","event","cause","actionableChange","some","isCompilableExtension","includes","verbose","log","catch","length"],"sources":["../../src/babel/file.ts"],"sourcesContent":["import convertSourceMap from \"convert-source-map\";\nimport { AnyMap, encodedMap } from \"@jridgewell/trace-mapping\";\nimport slash from \"slash\";\nimport path from \"path\";\nimport fs from \"fs\";\n\nimport * as util from \"./util.ts\";\nimport type { CmdOptions } from \"./options.ts\";\nimport * as watcher from \"./watcher.ts\";\n\nimport type {\n  EncodedSourceMap,\n  SectionedSourceMap,\n  SourceMapInput,\n  TraceMap,\n} from \"@jridgewell/trace-mapping\";\nimport type { FileResult } from \"@babel/core\";\n\ntype CompilationOutput = {\n  code: string;\n  map: SourceMapInput;\n  hasRawMap: boolean;\n};\n\nexport default async function ({\n  cliOptions,\n  babelOptions,\n}: CmdOptions): Promise<void> {\n  function buildResult(fileResults: Array<FileResult>): CompilationOutput {\n    const mapSections: SectionedSourceMap[\"sections\"] = [];\n\n    let code = \"\";\n    let offset = 0;\n\n    let hasRawMap = false;\n\n    for (const result of fileResults) {\n      if (!result) continue;\n\n      hasRawMap = !!result.map;\n\n      mapSections.push({\n        offset: { line: offset, column: 0 },\n        map: (result.map as EncodedSourceMap) || {\n          version: 3,\n          names: [],\n          sources: [],\n          mappings: [],\n        },\n      });\n\n      code += result.code + \"\\n\";\n      offset += countNewlines(result.code) + 1;\n    }\n\n    const map = new AnyMap({\n      version: 3,\n      file:\n        cliOptions.sourceMapTarget ||\n        path.basename(cliOptions.outFile || \"\") ||\n        \"stdout\",\n      sections: mapSections,\n    });\n    // For some reason, the spec doesn't allow sourceRoot when constructing a\n    // sectioned sourcemap. But AllMap returns a regular sourcemap, we can\n    // freely add to with a sourceRoot.\n    map.sourceRoot = babelOptions.sourceRoot;\n\n    // add the inline sourcemap comment if we've either explicitly asked for inline source\n    // maps, or we've requested them without any output file\n    if (\n      babelOptions.sourceMaps === \"inline\" ||\n      (!cliOptions.outFile && babelOptions.sourceMaps)\n    ) {\n      code += \"\\n\" + convertSourceMap.fromObject(encodedMap(map)).toComment();\n    }\n\n    return {\n      map: map,\n      code: code,\n      hasRawMap: hasRawMap,\n    };\n  }\n\n  function countNewlines(code: string): number {\n    let count = 0;\n    let index = -1;\n    while ((index = code.indexOf(\"\\n\", index + 1)) !== -1) {\n      count++;\n    }\n    return count;\n  }\n\n  function output(fileResults: Array<FileResult>): void {\n    const result = buildResult(fileResults);\n\n    if (cliOptions.outFile) {\n      fs.mkdirSync(path.dirname(cliOptions.outFile), { recursive: true });\n\n      let outputMap: \"both\" | \"external\" | false = false;\n      if (babelOptions.sourceMaps && babelOptions.sourceMaps !== \"inline\") {\n        outputMap = \"external\";\n      } else if (babelOptions.sourceMaps == undefined && result.hasRawMap) {\n        outputMap = util.hasDataSourcemap(result.code) ? \"external\" : \"both\";\n      }\n\n      if (outputMap) {\n        const mapLoc = cliOptions.outFile + \".map\";\n        if (outputMap === \"external\") {\n          result.code = util.addSourceMappingUrl(result.code, mapLoc);\n        }\n        fs.writeFileSync(\n          mapLoc,\n          JSON.stringify(encodedMap(result.map as TraceMap)),\n        );\n      }\n\n      fs.writeFileSync(cliOptions.outFile, result.code);\n    } else {\n      process.stdout.write(result.code + \"\\n\");\n    }\n  }\n\n  function readStdin(): Promise<string> {\n    return new Promise((resolve, reject): void => {\n      let code = \"\";\n\n      process.stdin.setEncoding(\"utf8\");\n\n      process.stdin.on(\"readable\", function () {\n        const chunk = process.stdin.read();\n        if (chunk !== null) code += chunk;\n      });\n\n      process.stdin.on(\"end\", function () {\n        resolve(code);\n      });\n      process.stdin.on(\"error\", reject);\n    });\n  }\n\n  async function stdin(): Promise<void> {\n    const code = await readStdin();\n\n    const res = await util.transformRepl(cliOptions.filename, code, {\n      ...babelOptions,\n      sourceFileName: \"stdin\",\n    });\n\n    output([res]);\n  }\n\n  async function walk(filenames: Array<string>): Promise<void> {\n    const _filenames: string[] = [];\n\n    filenames.forEach(function (filename) {\n      if (!fs.existsSync(filename)) return;\n\n      const stat = fs.statSync(filename);\n      if (stat.isDirectory()) {\n        const dirname = filename;\n\n        util\n          .readdirForCompilable(\n            filename,\n            cliOptions.includeDotfiles,\n            cliOptions.extensions,\n          )\n          .forEach(function (filename) {\n            _filenames.push(path.join(dirname, filename));\n          });\n      } else {\n        _filenames.push(filename);\n      }\n    });\n\n    const results = await Promise.all(\n      _filenames.map(async function (filename: string): Promise<any> {\n        let sourceFilename = filename;\n        if (cliOptions.outFile) {\n          sourceFilename = path.relative(\n            path.dirname(cliOptions.outFile),\n            sourceFilename,\n          );\n        }\n        sourceFilename = slash(sourceFilename);\n\n        try {\n          return await util.compile(filename, {\n            ...babelOptions,\n            sourceFileName: sourceFilename,\n            // Since we're compiling everything to be merged together,\n            // \"inline\" applies to the final output file, but not to the individual\n            // files being concatenated.\n            sourceMaps:\n              babelOptions.sourceMaps === \"inline\"\n                ? true\n                : babelOptions.sourceMaps,\n          });\n        } catch (err) {\n          if (!cliOptions.watch) {\n            throw err;\n          }\n\n          console.error(err);\n          return null;\n        }\n      }),\n    );\n\n    output(results);\n  }\n\n  async function files(filenames: Array<string>): Promise<void> {\n    if (cliOptions.watch) {\n      watcher.enable({ enableGlobbing: false });\n    }\n\n    if (!cliOptions.skipInitialBuild) {\n      await walk(filenames);\n    }\n\n    if (cliOptions.watch) {\n      filenames.forEach(watcher.watch);\n\n      watcher.startWatcher();\n\n      watcher.onFilesChange((changes, event, cause) => {\n        const actionableChange = changes.some(\n          filename =>\n            util.isCompilableExtension(filename, cliOptions.extensions) ||\n            filenames.includes(filename),\n        );\n        if (!actionableChange) return;\n\n        if (cliOptions.verbose) {\n          console.log(`${event} ${cause}`);\n        }\n\n        walk(filenames).catch(err => {\n          console.error(err);\n        });\n      });\n    }\n  }\n\n  if (cliOptions.filenames.length) {\n    await files(cliOptions.filenames);\n  } else {\n    await stdin();\n  }\n}\n"],"mappings":"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"}