Node.js's asynchronous nature
Note: This section just provides a general overview of blocking, non-blocking, and callback code. In my upcoming writings, I'll go into much more detail about these ideas. For the time being, we can loosely visualise the ideas and grasp their fundamentals.
You might have been curious as to what the term "synchronous" in the preceding section meant. Let's determine that.
The last block of code, when run, executes the code line by line. In essence, each line of code simply waits for the output of the preceding line. This is how the so-called synchronous programming model, sometimes known as blocking code, operates.
Asynchronous, non-blocking code makes the heavy work be handled in the background. Rest of the code present below is meanwhile executed. A callback function that we list before, is called when the heavy work is done and the result is controlled by it.
Node.js operates using a single thread. It signifies that there is just one thread in our Node.js process, which is where the code is running (think of a thread as a collection of instructions that run in a CPU). It's just the way Node.js was created. This indicates that a single thread is accessible to all users of our program. These users' code will be executed in the same thread on the machine hosting the application.
For instance, all other users must wait until the execution of a user-blocked synchronous piece of code is finished. When our audience numbers in the millions or even thousands, this might result in a poor user experience. On the other hand, asynchronous code handles the time-consuming job in the background while allowing other users to engage with the application. When the laborious job is finished, a callback function returns the outcome for that user.
Note: Keep in mind that our code is not asynchronous just because we use callback functions. Only some of the NodeAPI's functions, such as readFile() and many more that we shall examine in later posts, operate in this manner.