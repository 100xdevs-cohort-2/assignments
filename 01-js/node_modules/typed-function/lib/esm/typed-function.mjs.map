{"version":3,"file":"typed-function.mjs","names":["ok","notOk","undef","undefined","NOT_TYPED_FUNCTION","create","isPlainObject","x","constructor","Object","_types","name","test","Array","isArray","Date","RegExp","anyType","isAny","typeMap","typeList","nConversions","typed","createCount","findType","typeName","type","get","message","toLowerCase","otherName","TypeError","addTypes","types","beforeSpec","beforeIndex","index","length","newTypes","i","has","push","set","conversionsTo","affectedTypes","slice","concat","clear","Map","clearConversions","findTypeNames","value","matches","filter","isTypedFunction","entity","findSignature","fn","signature","options","exact","stringSignature","join","params","parseSignature","canonicalSignature","stringifyParams","signatures","match","_typedFunctionData","signatureMap","nParams","remainingSignatures","want","filteredSignatures","possibility","have","getParamAtIndex","restParam","hasAny","haveTypes","paramTypeSet","some","wtype","candidate","find","implementation","convert","conversions","Error","fromType","from","separator","map","p","parseParam","param","indexOf","typeDefs","split","s","trim","paramName","exactTypes","typeIndex","conversion","conversionIndex","hasConversion","expandParam","typeNames","t","matchingConversions","availableConversions","newName","convertibleTypes","typeSet","Set","forEach","add","rawSignature","rawParams","parsedParam","SyntaxError","hasRestParam","last","compileTest","test0","test1","or","tests","compileTests","initial","varIndex","lastTest","testRestParam","args","testArgs","getTypeSetAtIndex","isExactType","mergeExpectedParams","paramSet","createError","err","expected","_name","matchingSignatures","nextMatchingDefs","actualTypes","data","category","actual","lengths","Infinity","Math","min","apply","maxLength","max","expectedLength","argTypes","getLowestTypeIndex","getLowestConversionIndex","compareParams","param1","param2","typeDiff","convDiff","compareSignatures","signature1","signature2","pars1","pars2","last1","last2","hasRest1","hasRest2","any1","conv1","par","any2","conv2","lengthCriterion","comparisons","tc","thisComparison","c","sort","t1","t2","knownTypes","newMatch","compileArgsPreprocessing","fnConvert","compiledConversions","compileArgConversion","convertArgs","arguments","fnPreprocess","offset","preprocessRestParams","conversion0","conversion1","convertArg","arg","splitParams","_splitParams","paramsSoFar","resultingParams","flatMap","nextParam","conflicting","params1","params2","ii","typeSet1","typeSet2","overlap","len1","len2","restParam1","restParam2","clearResolutions","functionList","isReferToSelf","referToSelf","callback","isReferTo","makeReferTo","referTo","references","collectResolutions","resolvedReferences","reference","resolution","resolveReferences","self","resolvedFunctions","isResolved","fill","leftUnresolved","nothingResolved","validateDeprecatedThis","signaturesMap","deprecatedThisRegex","keys","toString","createTypedFunction","rawSignaturesMap","warnAgainstDeprecatedThis","parsedParams","originalFunctions","preliminarySignatures","prototype","hasOwnProperty","call","pp","functionIndex","conversionParams","sp","spName","every","theTypedFn","internalSignatureMap","ok0","ok1","ok2","ok3","ok4","ok5","allOk","test00","test10","test20","test30","test40","test50","test01","test11","test21","test31","test41","test51","fn0","fn1","fn2","fn3","fn4","fn5","len0","len3","len4","len5","iStart","iEnd","fns","generic","onMismatch","arg0","arg1","defineProperty","_onMismatch","arr","start","end","findInArray","objectOrFn","checkName","nameSoFar","getObjectName","obj","key","mergeSignatures","dest","source","sourceFunction","destFunction","saveTyped","maybeName","named","allSignatures","item","theseSignatures","thisName","argument","throwMismatchError","_findType","addType","beforeObjectTest","before","_validateConversion","to","addConversion","other","addConversions","removeConversion","existingConversion","splice","resolve","tf","argList","sigs"],"sources":["../../src/typed-function.mjs"],"sourcesContent":["function ok () {\n  return true\n}\n\nfunction notOk () {\n  return false\n}\n\nfunction undef () {\n  return undefined\n}\n\nconst NOT_TYPED_FUNCTION = 'Argument is not a typed-function.'\n\n/**\n * @typedef {{\n *   params: Param[],\n *   fn: function,\n *   test: function,\n *   implementation: function\n * }} Signature\n *\n * @typedef {{\n *   types: Type[],\n *   hasAny: boolean,\n *   hasConversion: boolean,\n *   restParam: boolean\n * }} Param\n *\n * @typedef {{\n *   name: string,\n *   typeIndex: number,\n *   test: function,\n *   isAny: boolean,\n *   conversion?: ConversionDef,\n *   conversionIndex: number,\n * }} Type\n *\n * @typedef {{\n *   from: string,\n *   to: string,\n *   convert: function (*) : *\n * }} ConversionDef\n *\n * @typedef {{\n *   name: string,\n *   test: function(*) : boolean,\n *   isAny?: boolean\n * }} TypeDef\n */\n\n/**\n * @returns {() => function}\n */\nfunction create () {\n  // data type tests\n\n  /**\n   * Returns true if the argument is a non-null \"plain\" object\n   */\n  function isPlainObject (x) {\n    return typeof x === 'object' && x !== null && x.constructor === Object\n  }\n\n  const _types = [\n    { name: 'number', test: function (x) { return typeof x === 'number' } },\n    { name: 'string', test: function (x) { return typeof x === 'string' } },\n    { name: 'boolean', test: function (x) { return typeof x === 'boolean' } },\n    { name: 'Function', test: function (x) { return typeof x === 'function' } },\n    { name: 'Array', test: Array.isArray },\n    { name: 'Date', test: function (x) { return x instanceof Date } },\n    { name: 'RegExp', test: function (x) { return x instanceof RegExp } },\n    { name: 'Object', test: isPlainObject },\n    { name: 'null', test: function (x) { return x === null } },\n    { name: 'undefined', test: function (x) { return x === undefined } }\n  ]\n\n  const anyType = {\n    name: 'any',\n    test: ok,\n    isAny: true\n  }\n\n  // Data structures to track the types. As these are local variables in\n  // create(), each typed universe will get its own copy, but the variables\n  // will only be accessible through the (closures of the) functions supplied\n  // as properties of the typed object, not directly.\n  // These will be initialized in clear() below\n  let typeMap // primary store of all types\n  let typeList // Array of just type names, for the sake of ordering\n\n  // And similar data structures for the type conversions:\n  let nConversions = 0\n  // the actual conversions are stored on a property of the destination types\n\n  // This is a temporary object, will be replaced with a function at the end\n  let typed = { createCount: 0 }\n\n  /**\n   * Takes a type name and returns the corresponding official type object\n   * for that type.\n   *\n   * @param {string} typeName\n   * @returns {TypeDef} type\n   */\n  function findType (typeName) {\n    const type = typeMap.get(typeName)\n    if (type) {\n      return type\n    }\n    // Remainder is error handling\n    let message = 'Unknown type \"' + typeName + '\"'\n    const name = typeName.toLowerCase()\n    let otherName\n    for (otherName of typeList) {\n      if (otherName.toLowerCase() === name) {\n        message += '. Did you mean \"' + otherName + '\" ?'\n        break\n      }\n    }\n    throw new TypeError(message)\n  }\n\n  /**\n   * Adds an array `types` of type definitions to this typed instance.\n   * Each type definition should be an object with properties:\n   * 'name' - a string giving the name of the type; 'test' - function\n   * returning a boolean that tests membership in the type; and optionally\n   * 'isAny' - true only for the 'any' type.\n   *\n   * The second optional argument, `before`, gives the name of a type that\n   * these types should be added before. The new types are added in the\n   * order specified.\n   * @param {TypeDef[]} types\n   * @param {string | boolean} [beforeSpec='any'] before\n   */\n  function addTypes (types, beforeSpec = 'any') {\n    const beforeIndex = beforeSpec\n      ? findType(beforeSpec).index\n      : typeList.length\n    const newTypes = []\n    for (let i = 0; i < types.length; ++i) {\n      if (!types[i] || typeof types[i].name !== 'string' ||\n          typeof types[i].test !== 'function') {\n        throw new TypeError('Object with properties {name: string, test: function} expected')\n      }\n      const typeName = types[i].name\n      if (typeMap.has(typeName)) {\n        throw new TypeError('Duplicate type name \"' + typeName + '\"')\n      }\n      newTypes.push(typeName)\n      typeMap.set(typeName, {\n        name: typeName,\n        test: types[i].test,\n        isAny: types[i].isAny,\n        index: beforeIndex + i,\n        conversionsTo: [] // Newly added type can't have any conversions to it\n      })\n    }\n    // update the typeList\n    const affectedTypes = typeList.slice(beforeIndex)\n    typeList =\n      typeList.slice(0, beforeIndex).concat(newTypes).concat(affectedTypes)\n    // Fix the indices\n    for (let i = beforeIndex + newTypes.length; i < typeList.length; ++i) {\n      typeMap.get(typeList[i]).index = i\n    }\n  }\n\n  /**\n   * Removes all types and conversions from this typed instance.\n   * May cause previously constructed typed-functions to throw\n   * strange errors when they are called with types that do not\n   * match any of their signatures.\n   */\n  function clear () {\n    typeMap = new Map()\n    typeList = []\n    nConversions = 0\n    addTypes([anyType], false)\n  }\n\n  // initialize the types to the default list\n  clear()\n  addTypes(_types)\n\n  /**\n   * Removes all conversions, leaving the types alone.\n   */\n  function clearConversions () {\n    let typeName\n    for (typeName of typeList) {\n      typeMap.get(typeName).conversionsTo = []\n    }\n    nConversions = 0\n  }\n\n  /**\n   * Find the type names that match a value.\n   * @param {*} value\n   * @return {string[]} Array of names of types for which\n   *                  the type test matches the value.\n   */\n  function findTypeNames (value) {\n    const matches = typeList.filter(name => {\n      const type = typeMap.get(name)\n      return !type.isAny && type.test(value)\n    })\n    if (matches.length) {\n      return matches\n    }\n    return ['any']\n  }\n\n  /**\n   * Check if an entity is a typed function created by any instance\n   * @param {any} entity\n   * @returns {boolean}\n   */\n  function isTypedFunction (entity) {\n    return entity && typeof entity === 'function' &&\n      '_typedFunctionData' in entity\n  }\n\n  /**\n   * Find a specific signature from a (composed) typed function, for example:\n   *\n   *   typed.findSignature(fn, ['number', 'string'])\n   *   typed.findSignature(fn, 'number, string')\n   *   typed.findSignature(fn, 'number,string', {exact: true})\n   *\n   * This function findSignature will by default return the best match to\n   * the given signature, possibly employing type conversions.\n   *\n   * The (optional) third argument is a plain object giving options\n   * controlling the signature search. Currently the only implemented\n   * option is `exact`: if specified as true (default is false), only\n   * exact matches will be returned (i.e. signatures for which `fn` was\n   * directly defined). Note that a (possibly different) type matching\n   * `any`, or one or more instances of TYPE matching `...TYPE` are\n   * considered exact matches in this regard, as no conversions are used.\n   *\n   * This function returns a \"signature\" object, as does `typed.resolve()`,\n   * which is a plain object with four keys: `params` (the array of parameters\n   * for this signature), `fn` (the originally supplied function for this\n   * signature), `test` (a generated function that determines if an argument\n   * list matches this signature, and `implementation` (the function to call\n   * on a matching argument list, that performs conversions if necessary and\n   * then calls the originally supplied function).\n   *\n   * @param {Function} fn                   A typed-function\n   * @param {string | string[]} signature\n   *     Signature to be found, can be an array or a comma separated string.\n   * @param {object} options  Controls the signature search as documented\n   * @return {{ params: Param[], fn: function, test: function, implementation: function }}\n   *     Returns the matching signature, or throws an error when no signature\n   *     is found.\n   */\n  function findSignature (fn, signature, options) {\n    if (!isTypedFunction(fn)) {\n      throw new TypeError(NOT_TYPED_FUNCTION)\n    }\n\n    // Canonicalize input\n    const exact = options && options.exact\n    const stringSignature = Array.isArray(signature)\n      ? signature.join(',')\n      : signature\n    const params = parseSignature(stringSignature)\n    const canonicalSignature = stringifyParams(params)\n\n    // First hope we get lucky and exactly match a signature\n    if (!exact || canonicalSignature in fn.signatures) {\n      // OK, we can check the internal signatures\n      const match =\n        fn._typedFunctionData.signatureMap.get(canonicalSignature)\n      if (match) {\n        return match\n      }\n    }\n\n    // Oh well, we did not; so we have to go back and check the parameters\n    // one by one, in order to catch things like `any` and rest params.\n    // Note here we can assume there is at least one parameter, because\n    // the empty signature would have matched successfully above.\n    const nParams = params.length\n    let remainingSignatures\n    if (exact) {\n      remainingSignatures = []\n      let name\n      for (name in fn.signatures) {\n        remainingSignatures.push(fn._typedFunctionData.signatureMap.get(name))\n      }\n    } else {\n      remainingSignatures = fn._typedFunctionData.signatures\n    }\n    for (let i = 0; i < nParams; ++i) {\n      const want = params[i]\n      const filteredSignatures = []\n      let possibility\n      for (possibility of remainingSignatures) {\n        const have = getParamAtIndex(possibility.params, i)\n        if (!have || (want.restParam && !have.restParam)) {\n          continue\n        }\n        if (!have.hasAny) {\n          // have to check all of the wanted types are available\n          const haveTypes = paramTypeSet(have)\n          if (want.types.some(wtype => !haveTypes.has(wtype.name))) {\n            continue\n          }\n        }\n        // OK, this looks good\n        filteredSignatures.push(possibility)\n      }\n      remainingSignatures = filteredSignatures\n      if (remainingSignatures.length === 0) break\n    }\n    // Return the first remaining signature that was totally matched:\n    let candidate\n    for (candidate of remainingSignatures) {\n      if (candidate.params.length <= nParams) {\n        return candidate\n      }\n    }\n\n    throw new TypeError('Signature not found (signature: ' + (fn.name || 'unnamed') + '(' + stringifyParams(params, ', ') + '))')\n  }\n\n  /**\n   * Find the proper function to call for a specific signature from\n   * a (composed) typed function, for example:\n   *\n   *   typed.find(fn, ['number', 'string'])\n   *   typed.find(fn, 'number, string')\n   *   typed.find(fn, 'number,string', {exact: true})\n   *\n   * This function find will by default return the best match to\n   * the given signature, possibly employing type conversions (and returning\n   * a function that will perform those conversions as needed). The\n   * (optional) third argument is a plain object giving options contolling\n   * the signature search. Currently only the option `exact` is implemented,\n   * which defaults to \"false\". If `exact` is specified as true, then only\n   * exact matches will be returned (i.e. signatures for which `fn` was\n   * directly defined). Uses of `any` and `...TYPE` are considered exact if\n   * no conversions are necessary to apply the corresponding function.\n   *\n   * @param {Function} fn                   A typed-function\n   * @param {string | string[]} signature\n   *     Signature to be found, can be an array or a comma separated string.\n   * @param {object} options  Controls the signature match as documented\n   * @return {function}\n   *     Returns the function to call for the given signature, or throws an\n   *     error if no match is found.\n   */\n  function find (fn, signature, options) {\n    return findSignature(fn, signature, options).implementation\n  }\n\n  /**\n   * Convert a given value to another data type, specified by type name.\n   *\n   * @param {*} value\n   * @param {string} typeName\n   */\n  function convert (value, typeName) {\n    // check conversion is needed\n    const type = findType(typeName)\n    if (type.test(value)) {\n      return value\n    }\n    const conversions = type.conversionsTo\n    if (conversions.length === 0) {\n      throw new Error(\n        'There are no conversions to ' + typeName + ' defined.')\n    }\n    for (let i = 0; i < conversions.length; i++) {\n      const fromType = findType(conversions[i].from)\n      if (fromType.test(value)) {\n        return conversions[i].convert(value)\n      }\n    }\n\n    throw new Error('Cannot convert ' + value + ' to ' + typeName)\n  }\n\n  /**\n   * Stringify parameters in a normalized way\n   * @param {Param[]} params\n   * @param {string} [','] separator\n   * @return {string}\n   */\n  function stringifyParams (params, separator = ',') {\n    return params.map(p => p.name).join(separator)\n  }\n\n  /**\n   * Parse a parameter, like \"...number | boolean\"\n   * @param {string} param\n   * @return {Param} param\n   */\n  function parseParam (param) {\n    const restParam = param.indexOf('...') === 0\n    const types = (!restParam)\n      ? param\n      : (param.length > 3)\n          ? param.slice(3)\n          : 'any'\n\n    const typeDefs = types.split('|').map(s => findType(s.trim()))\n\n    let hasAny = false\n    let paramName = restParam ? '...' : ''\n\n    const exactTypes = typeDefs.map(function (type) {\n      hasAny = type.isAny || hasAny\n      paramName += type.name + '|'\n\n      return {\n        name: type.name,\n        typeIndex: type.index,\n        test: type.test,\n        isAny: type.isAny,\n        conversion: null,\n        conversionIndex: -1\n      }\n    })\n\n    return {\n      types: exactTypes,\n      name: paramName.slice(0, -1), // remove trailing '|' from above\n      hasAny,\n      hasConversion: false,\n      restParam\n    }\n  }\n\n  /**\n   * Expands a parsed parameter with the types available from currently\n   * defined conversions.\n   * @param {Param} param\n   * @return {Param} param\n   */\n  function expandParam (param) {\n    const typeNames = param.types.map(t => t.name)\n    const matchingConversions = availableConversions(typeNames)\n    let hasAny = param.hasAny\n    let newName = param.name\n\n    const convertibleTypes = matchingConversions.map(function (conversion) {\n      const type = findType(conversion.from)\n      hasAny = type.isAny || hasAny\n      newName += '|' + conversion.from\n\n      return {\n        name: conversion.from,\n        typeIndex: type.index,\n        test: type.test,\n        isAny: type.isAny,\n        conversion,\n        conversionIndex: conversion.index\n      }\n    })\n\n    return {\n      types: param.types.concat(convertibleTypes),\n      name: newName,\n      hasAny,\n      hasConversion: convertibleTypes.length > 0,\n      restParam: param.restParam\n    }\n  }\n\n  /**\n   * Return the set of type names in a parameter.\n   * Caches the result for efficiency\n   *\n   * @param {Param} param\n   * @return {Set<string>} typenames\n   */\n  function paramTypeSet (param) {\n    if (!param.typeSet) {\n      param.typeSet = new Set()\n      param.types.forEach(type => param.typeSet.add(type.name))\n    }\n    return param.typeSet\n  }\n\n  /**\n   * Parse a signature with comma separated parameters,\n   * like \"number | boolean, ...string\"\n   *\n   * @param {string} signature\n   * @return {Param[]} params\n   */\n  function parseSignature (rawSignature) {\n    const params = []\n    if (typeof rawSignature !== 'string') {\n      throw new TypeError('Signatures must be strings')\n    }\n    const signature = rawSignature.trim()\n    if (signature === '') {\n      return params\n    }\n\n    const rawParams = signature.split(',')\n    for (let i = 0; i < rawParams.length; ++i) {\n      const parsedParam = parseParam(rawParams[i].trim())\n      if (parsedParam.restParam && (i !== rawParams.length - 1)) {\n        throw new SyntaxError(\n          'Unexpected rest parameter \"' + rawParams[i] + '\": ' +\n          'only allowed for the last parameter')\n      }\n      // if invalid, short-circuit (all the types may have been filtered)\n      if (parsedParam.types.length === 0) {\n        return null\n      }\n      params.push(parsedParam)\n    }\n\n    return params\n  }\n\n  /**\n   * Test whether a set of params contains a restParam\n   * @param {Param[]} params\n   * @return {boolean} Returns true when the last parameter is a restParam\n   */\n  function hasRestParam (params) {\n    const param = last(params)\n    return param ? param.restParam : false\n  }\n\n  /**\n   * Create a type test for a single parameter, which can have one or multiple\n   * types.\n   * @param {Param} param\n   * @return {function(x: *) : boolean} Returns a test function\n   */\n  function compileTest (param) {\n    if (!param || param.types.length === 0) {\n      // nothing to do\n      return ok\n    } else if (param.types.length === 1) {\n      return findType(param.types[0].name).test\n    } else if (param.types.length === 2) {\n      const test0 = findType(param.types[0].name).test\n      const test1 = findType(param.types[1].name).test\n      return function or (x) {\n        return test0(x) || test1(x)\n      }\n    } else { // param.types.length > 2\n      const tests = param.types.map(function (type) {\n        return findType(type.name).test\n      })\n      return function or (x) {\n        for (let i = 0; i < tests.length; i++) {\n          if (tests[i](x)) {\n            return true\n          }\n        }\n        return false\n      }\n    }\n  }\n\n  /**\n   * Create a test for all parameters of a signature\n   * @param {Param[]} params\n   * @return {function(args: Array<*>) : boolean}\n   */\n  function compileTests (params) {\n    let tests, test0, test1\n\n    if (hasRestParam(params)) {\n      // variable arguments like '...number'\n      tests = initial(params).map(compileTest)\n      const varIndex = tests.length\n      const lastTest = compileTest(last(params))\n      const testRestParam = function (args) {\n        for (let i = varIndex; i < args.length; i++) {\n          if (!lastTest(args[i])) {\n            return false\n          }\n        }\n        return true\n      }\n\n      return function testArgs (args) {\n        for (let i = 0; i < tests.length; i++) {\n          if (!tests[i](args[i])) {\n            return false\n          }\n        }\n        return testRestParam(args) && (args.length >= varIndex + 1)\n      }\n    } else {\n      // no variable arguments\n      if (params.length === 0) {\n        return function testArgs (args) {\n          return args.length === 0\n        }\n      } else if (params.length === 1) {\n        test0 = compileTest(params[0])\n        return function testArgs (args) {\n          return test0(args[0]) && args.length === 1\n        }\n      } else if (params.length === 2) {\n        test0 = compileTest(params[0])\n        test1 = compileTest(params[1])\n        return function testArgs (args) {\n          return test0(args[0]) && test1(args[1]) && args.length === 2\n        }\n      } else { // arguments.length > 2\n        tests = params.map(compileTest)\n        return function testArgs (args) {\n          for (let i = 0; i < tests.length; i++) {\n            if (!tests[i](args[i])) {\n              return false\n            }\n          }\n          return args.length === tests.length\n        }\n      }\n    }\n  }\n\n  /**\n   * Find the parameter at a specific index of a Params list.\n   * Handles rest parameters.\n   * @param {Param[]} params\n   * @param {number} index\n   * @return {Param | null} Returns the matching parameter when found,\n   *                        null otherwise.\n   */\n  function getParamAtIndex (params, index) {\n    return index < params.length\n      ? params[index]\n      : hasRestParam(params) ? last(params) : null\n  }\n\n  /**\n   * Get all type names of a parameter\n   * @param {Params[]} params\n   * @param {number} index\n   * @return {string[]} Returns an array with type names\n   */\n  function getTypeSetAtIndex (params, index) {\n    const param = getParamAtIndex(params, index)\n    if (!param) {\n      return new Set()\n    }\n    return paramTypeSet(param)\n  }\n\n  /**\n   * Test whether a type is an exact type or conversion\n   * @param {Type} type\n   * @return {boolean} Returns true when\n   */\n  function isExactType (type) {\n    return type.conversion === null || type.conversion === undefined\n  }\n\n  /**\n   * Helper function for creating error messages: create an array with\n   * all available types on a specific argument index.\n   * @param {Signature[]} signatures\n   * @param {number} index\n   * @return {string[]} Returns an array with available types\n   */\n  function mergeExpectedParams (signatures, index) {\n    const typeSet = new Set()\n    signatures.forEach(signature => {\n      const paramSet = getTypeSetAtIndex(signature.params, index)\n      let name\n      for (name of paramSet) {\n        typeSet.add(name)\n      }\n    })\n\n    return typeSet.has('any') ? ['any'] : Array.from(typeSet)\n  }\n\n  /**\n   * Create\n   * @param {string} name             The name of the function\n   * @param {array.<*>} args          The actual arguments passed to the function\n   * @param {Signature[]} signatures  A list with available signatures\n   * @return {TypeError} Returns a type error with additional data\n   *                     attached to it in the property `data`\n   */\n  function createError (name, args, signatures) {\n    let err, expected\n    const _name = name || 'unnamed'\n\n    // test for wrong type at some index\n    let matchingSignatures = signatures\n    let index\n    for (index = 0; index < args.length; index++) {\n      const nextMatchingDefs = []\n      matchingSignatures.forEach(signature => {\n        const param = getParamAtIndex(signature.params, index)\n        const test = compileTest(param)\n        if ((index < signature.params.length ||\n             hasRestParam(signature.params)) &&\n            test(args[index])) {\n          nextMatchingDefs.push(signature)\n        }\n      })\n\n      if (nextMatchingDefs.length === 0) {\n        // no matching signatures anymore, throw error \"wrong type\"\n        expected = mergeExpectedParams(matchingSignatures, index)\n        if (expected.length > 0) {\n          const actualTypes = findTypeNames(args[index])\n\n          err = new TypeError('Unexpected type of argument in function ' + _name +\n              ' (expected: ' + expected.join(' or ') +\n              ', actual: ' + actualTypes.join(' | ') + ', index: ' + index + ')')\n          err.data = {\n            category: 'wrongType',\n            fn: _name,\n            index,\n            actual: actualTypes,\n            expected\n          }\n          return err\n        }\n      } else {\n        matchingSignatures = nextMatchingDefs\n      }\n    }\n\n    // test for too few arguments\n    const lengths = matchingSignatures.map(function (signature) {\n      return hasRestParam(signature.params)\n        ? Infinity\n        : signature.params.length\n    })\n    if (args.length < Math.min.apply(null, lengths)) {\n      expected = mergeExpectedParams(matchingSignatures, index)\n      err = new TypeError('Too few arguments in function ' + _name +\n          ' (expected: ' + expected.join(' or ') +\n          ', index: ' + args.length + ')')\n      err.data = {\n        category: 'tooFewArgs',\n        fn: _name,\n        index: args.length,\n        expected\n      }\n      return err\n    }\n\n    // test for too many arguments\n    const maxLength = Math.max.apply(null, lengths)\n    if (args.length > maxLength) {\n      err = new TypeError('Too many arguments in function ' + _name +\n          ' (expected: ' + maxLength + ', actual: ' + args.length + ')')\n      err.data = {\n        category: 'tooManyArgs',\n        fn: _name,\n        index: args.length,\n        expectedLength: maxLength\n      }\n      return err\n    }\n\n    // Generic error\n    const argTypes = []\n    for (let i = 0; i < args.length; ++i) {\n      argTypes.push(findTypeNames(args[i]).join('|'))\n    }\n    err = new TypeError('Arguments of type \"' + argTypes.join(', ') +\n        '\" do not match any of the defined signatures of function ' + _name + '.')\n    err.data = {\n      category: 'mismatch',\n      actual: argTypes\n    }\n    return err\n  }\n\n  /**\n   * Find the lowest index of all exact types of a parameter (no conversions)\n   * @param {Param} param\n   * @return {number} Returns the index of the lowest type in typed.types\n   */\n  function getLowestTypeIndex (param) {\n    let min = typeList.length + 1\n\n    for (let i = 0; i < param.types.length; i++) {\n      if (isExactType(param.types[i])) {\n        min = Math.min(min, param.types[i].typeIndex)\n      }\n    }\n\n    return min\n  }\n\n  /**\n   * Find the lowest index of the conversion of all types of the parameter\n   * having a conversion\n   * @param {Param} param\n   * @return {number} Returns the lowest index of the conversions of this type\n   */\n  function getLowestConversionIndex (param) {\n    let min = nConversions + 1\n\n    for (let i = 0; i < param.types.length; i++) {\n      if (!isExactType(param.types[i])) {\n        min = Math.min(min, param.types[i].conversionIndex)\n      }\n    }\n\n    return min\n  }\n\n  /**\n   * Compare two params\n   * @param {Param} param1\n   * @param {Param} param2\n   * @return {number} returns -1 when param1 must get a lower\n   *                  index than param2, 1 when the opposite,\n   *                  or zero when both are equal\n   */\n  function compareParams (param1, param2) {\n    // We compare a number of metrics on a param in turn:\n    // 1) 'any' parameters are the least preferred\n    if (param1.hasAny) {\n      if (!param2.hasAny) {\n        return 1\n      }\n    } else if (param2.hasAny) {\n      return -1\n    }\n\n    // 2) Prefer non-rest to rest parameters\n    if (param1.restParam) {\n      if (!param2.restParam) {\n        return 1\n      }\n    } else if (param2.restParam) {\n      return -1\n    }\n\n    // 3) Prefer exact type match to conversions\n    if (param1.hasConversion) {\n      if (!param2.hasConversion) {\n        return 1\n      }\n    } else if (param2.hasConversion) {\n      return -1\n    }\n\n    // 4) Prefer lower type index:\n    const typeDiff = getLowestTypeIndex(param1) - getLowestTypeIndex(param2)\n    if (typeDiff < 0) {\n      return -1\n    }\n    if (typeDiff > 0) {\n      return 1\n    }\n\n    // 5) Prefer lower conversion index\n    const convDiff =\n      getLowestConversionIndex(param1) - getLowestConversionIndex(param2)\n    if (convDiff < 0) {\n      return -1\n    }\n    if (convDiff > 0) {\n      return 1\n    }\n\n    // Don't have a basis for preference\n    return 0\n  }\n\n  /**\n   * Compare two signatures\n   * @param {Signature} signature1\n   * @param {Signature} signature2\n   * @return {number} returns a negative number when param1 must get a lower\n   *                  index than param2, a positive number when the opposite,\n   *                  or zero when both are equal\n   */\n  function compareSignatures (signature1, signature2) {\n    const pars1 = signature1.params\n    const pars2 = signature2.params\n    const last1 = last(pars1)\n    const last2 = last(pars2)\n    const hasRest1 = hasRestParam(pars1)\n    const hasRest2 = hasRestParam(pars2)\n    // We compare a number of metrics on signatures in turn:\n    // 1) An \"any rest param\" is least preferred\n    if (hasRest1 && last1.hasAny) {\n      if (!hasRest2 || !last2.hasAny) {\n        return 1\n      }\n    } else if (hasRest2 && last2.hasAny) {\n      return -1\n    }\n\n    // 2) Minimize the number of 'any' parameters\n    let any1 = 0\n    let conv1 = 0\n    let par\n    for (par of pars1) {\n      if (par.hasAny) ++any1\n      if (par.hasConversion) ++conv1\n    }\n    let any2 = 0\n    let conv2 = 0\n    for (par of pars2) {\n      if (par.hasAny) ++any2\n      if (par.hasConversion) ++conv2\n    }\n    if (any1 !== any2) {\n      return any1 - any2\n    }\n\n    // 3) A conversion rest param is less preferred\n    if (hasRest1 && last1.hasConversion) {\n      if (!hasRest2 || !last2.hasConversion) {\n        return 1\n      }\n    } else if (hasRest2 && last2.hasConversion) {\n      return -1\n    }\n\n    // 4) Minimize the number of conversions\n    if (conv1 !== conv2) {\n      return conv1 - conv2\n    }\n\n    // 5) Prefer no rest param\n    if (hasRest1) {\n      if (!hasRest2) {\n        return 1\n      }\n    } else if (hasRest2) {\n      return -1\n    }\n\n    // 6) Prefer shorter with rest param, longer without\n    const lengthCriterion =\n      (pars1.length - pars2.length) * (hasRest1 ? -1 : 1)\n    if (lengthCriterion !== 0) {\n      return lengthCriterion\n    }\n\n    // Signatures are identical in each of the above metrics.\n    // In particular, they are the same length.\n    // We can therefore compare the parameters one by one.\n    // First we count which signature has more preferred parameters.\n    const comparisons = []\n    let tc = 0\n    for (let i = 0; i < pars1.length; ++i) {\n      const thisComparison = compareParams(pars1[i], pars2[i])\n      comparisons.push(thisComparison)\n      tc += thisComparison\n    }\n    if (tc !== 0) {\n      return tc\n    }\n\n    // They have the same number of preferred parameters, so go by the\n    // earliest parameter in which we have a preference.\n    // In other words, dispatch is driven somewhat more by earlier\n    // parameters than later ones.\n    let c\n    for (c of comparisons) {\n      if (c !== 0) {\n        return c\n      }\n    }\n\n    // It's a tossup:\n    return 0\n  }\n\n  /**\n   * Produce a list of all conversions from distinct types to one of\n   * the given types.\n   *\n   * @param {string[]} typeNames\n   * @return {ConversionDef[]} Returns the conversions that are available\n   *                        resulting in any given type (if any)\n   */\n  function availableConversions (typeNames) {\n    if (typeNames.length === 0) {\n      return []\n    }\n    const types = typeNames.map(findType)\n    if (typeNames.length > 1) {\n      types.sort((t1, t2) => t1.index - t2.index)\n    }\n    let matches = types[0].conversionsTo\n    if (typeNames.length === 1) {\n      return matches\n    }\n\n    matches = matches.concat([]) // shallow copy the matches\n    // Since the types are now in index order, we just want the first\n    // occurrence of any from type:\n    const knownTypes = new Set(typeNames)\n    for (let i = 1; i < types.length; ++i) {\n      let newMatch\n      for (newMatch of types[i].conversionsTo) {\n        if (!knownTypes.has(newMatch.from)) {\n          matches.push(newMatch)\n          knownTypes.add(newMatch.from)\n        }\n      }\n    }\n\n    return matches\n  }\n\n  /**\n   * Preprocess arguments before calling the original function:\n   * - if needed convert the parameters\n   * - in case of rest parameters, move the rest parameters into an Array\n   * @param {Param[]} params\n   * @param {function} fn\n   * @return {function} Returns a wrapped function\n   */\n  function compileArgsPreprocessing (params, fn) {\n    let fnConvert = fn\n\n    // TODO: can we make this wrapper function smarter/simpler?\n\n    if (params.some(p => p.hasConversion)) {\n      const restParam = hasRestParam(params)\n      const compiledConversions = params.map(compileArgConversion)\n\n      fnConvert = function convertArgs () {\n        const args = []\n        const last = restParam ? arguments.length - 1 : arguments.length\n        for (let i = 0; i < last; i++) {\n          args[i] = compiledConversions[i](arguments[i])\n        }\n        if (restParam) {\n          args[last] = arguments[last].map(compiledConversions[last])\n        }\n\n        return fn.apply(this, args)\n      }\n    }\n\n    let fnPreprocess = fnConvert\n    if (hasRestParam(params)) {\n      const offset = params.length - 1\n\n      fnPreprocess = function preprocessRestParams () {\n        return fnConvert.apply(this,\n          slice(arguments, 0, offset).concat([slice(arguments, offset)]))\n      }\n    }\n\n    return fnPreprocess\n  }\n\n  /**\n   * Compile conversion for a parameter to the right type\n   * @param {Param} param\n   * @return {function} Returns the wrapped function that will convert arguments\n   *\n   */\n  function compileArgConversion (param) {\n    let test0, test1, conversion0, conversion1\n    const tests = []\n    const conversions = []\n\n    param.types.forEach(function (type) {\n      if (type.conversion) {\n        tests.push(findType(type.conversion.from).test)\n        conversions.push(type.conversion.convert)\n      }\n    })\n\n    // create optimized conversion functions depending on the number of conversions\n    switch (conversions.length) {\n      case 0:\n        return function convertArg (arg) {\n          return arg\n        }\n\n      case 1:\n        test0 = tests[0]\n        conversion0 = conversions[0]\n        return function convertArg (arg) {\n          if (test0(arg)) {\n            return conversion0(arg)\n          }\n          return arg\n        }\n\n      case 2:\n        test0 = tests[0]\n        test1 = tests[1]\n        conversion0 = conversions[0]\n        conversion1 = conversions[1]\n        return function convertArg (arg) {\n          if (test0(arg)) {\n            return conversion0(arg)\n          }\n          if (test1(arg)) {\n            return conversion1(arg)\n          }\n          return arg\n        }\n\n      default:\n        return function convertArg (arg) {\n          for (let i = 0; i < conversions.length; i++) {\n            if (tests[i](arg)) {\n              return conversions[i](arg)\n            }\n          }\n          return arg\n        }\n    }\n  }\n\n  /**\n   * Split params with union types in to separate params.\n   *\n   * For example:\n   *\n   *     splitParams([['Array', 'Object'], ['string', 'RegExp'])\n   *     // returns:\n   *     // [\n   *     //   ['Array', 'string'],\n   *     //   ['Array', 'RegExp'],\n   *     //   ['Object', 'string'],\n   *     //   ['Object', 'RegExp']\n   *     // ]\n   *\n   * @param {Param[]} params\n   * @return {Param[]}\n   */\n  function splitParams (params) {\n    function _splitParams (params, index, paramsSoFar) {\n      if (index < params.length) {\n        const param = params[index]\n        let resultingParams = []\n\n        if (param.restParam) {\n          // split the types of a rest parameter in two:\n          // one with only exact types, and one with exact types and conversions\n          const exactTypes = param.types.filter(isExactType)\n          if (exactTypes.length < param.types.length) {\n            resultingParams.push({\n              types: exactTypes,\n              name: '...' + exactTypes.map(t => t.name).join('|'),\n              hasAny: exactTypes.some(t => t.isAny),\n              hasConversion: false,\n              restParam: true\n            })\n          }\n          resultingParams.push(param)\n        } else {\n          // split all the types of a regular parameter into one type per param\n          resultingParams = param.types.map(function (type) {\n            return {\n              types: [type],\n              name: type.name,\n              hasAny: type.isAny,\n              hasConversion: type.conversion,\n              restParam: false\n            }\n          })\n        }\n\n        // recurse over the groups with types\n        return flatMap(resultingParams, function (nextParam) {\n          return _splitParams(params, index + 1, paramsSoFar.concat([nextParam]))\n        })\n      } else {\n        // we've reached the end of the parameters.\n        return [paramsSoFar]\n      }\n    }\n\n    return _splitParams(params, 0, [])\n  }\n\n  /**\n   * Test whether two param lists represent conflicting signatures\n   * @param {Param[]} params1\n   * @param {Param[]} params2\n   * @return {boolean} Returns true when the signatures conflict, false otherwise.\n   */\n  function conflicting (params1, params2) {\n    const ii = Math.max(params1.length, params2.length)\n\n    for (let i = 0; i < ii; i++) {\n      const typeSet1 = getTypeSetAtIndex(params1, i)\n      const typeSet2 = getTypeSetAtIndex(params2, i)\n      let overlap = false\n      let name\n      for (name of typeSet2) {\n        if (typeSet1.has(name)) {\n          overlap = true\n          break\n        }\n      }\n      if (!overlap) {\n        return false\n      }\n    }\n\n    const len1 = params1.length\n    const len2 = params2.length\n    const restParam1 = hasRestParam(params1)\n    const restParam2 = hasRestParam(params2)\n\n    return restParam1\n      ? restParam2 ? (len1 === len2) : (len2 >= len1)\n      : restParam2 ? (len1 >= len2) : (len1 === len2)\n  }\n\n  /**\n   * Helper function for `resolveReferences` that returns a copy of\n   * functionList wihe any prior resolutions cleared out, in case we are\n   * recycling signatures from a prior typed function construction.\n   *\n   * @param {Array.<function|typed-reference>} functionList\n   * @return {Array.<function|typed-reference>}\n   */\n  function clearResolutions (functionList) {\n    return functionList.map(fn => {\n      if (isReferToSelf(fn)) {\n        return referToSelf(fn.referToSelf.callback)\n      }\n      if (isReferTo(fn)) {\n        return makeReferTo(fn.referTo.references, fn.referTo.callback)\n      }\n      return fn\n    })\n  }\n\n  /**\n   * Take a list of references, a list of functions functionList, and a\n   * signatureMap indexing signatures into functionList, and return\n   * the list of resolutions, or a false-y value if they don't all\n   * resolve in a valid way (yet).\n   *\n   * @param {string[]} references\n   * @param {Array<function|typed-reference} functionList\n   * @param {Object.<string, integer>} signatureMap\n   * @return {function[] | false} resolutions\n   */\n  function collectResolutions (references, functionList, signatureMap) {\n    const resolvedReferences = []\n    let reference\n    for (reference of references) {\n      let resolution = signatureMap[reference]\n      if (typeof resolution !== 'number') {\n        throw new TypeError(\n          'No definition for referenced signature \"' + reference + '\"')\n      }\n      resolution = functionList[resolution]\n      if (typeof resolution !== 'function') {\n        return false\n      }\n      resolvedReferences.push(resolution)\n    }\n    return resolvedReferences\n  }\n\n  /**\n   * Resolve any references in the functionList for the typed function\n   * itself. The signatureMap tells which index in the functionList a\n   * given signature should be mapped to (for use in resolving typed.referTo)\n   * and self provides the destions of a typed.referToSelf.\n   *\n   * @param {Array<function | typed-reference-object>} functionList\n   * @param {Object.<string, function>} signatureMap\n   * @param {function} self  The typed-function itself\n   * @return {Array<function>} The list of resolved functions\n   */\n  function resolveReferences (functionList, signatureMap, self) {\n    const resolvedFunctions = clearResolutions(functionList)\n    const isResolved = new Array(resolvedFunctions.length).fill(false)\n    let leftUnresolved = true\n    while (leftUnresolved) {\n      leftUnresolved = false\n      let nothingResolved = true\n      for (let i = 0; i < resolvedFunctions.length; ++i) {\n        if (isResolved[i]) continue\n        const fn = resolvedFunctions[i]\n\n        if (isReferToSelf(fn)) {\n          resolvedFunctions[i] = fn.referToSelf.callback(self)\n          // Preserve reference in case signature is reused someday:\n          resolvedFunctions[i].referToSelf = fn.referToSelf\n          isResolved[i] = true\n          nothingResolved = false\n        } else if (isReferTo(fn)) {\n          const resolvedReferences = collectResolutions(\n            fn.referTo.references, resolvedFunctions, signatureMap)\n          if (resolvedReferences) {\n            resolvedFunctions[i] =\n              fn.referTo.callback.apply(this, resolvedReferences)\n            // Preserve reference in case signature is reused someday:\n            resolvedFunctions[i].referTo = fn.referTo\n            isResolved[i] = true\n            nothingResolved = false\n          } else {\n            leftUnresolved = true\n          }\n        }\n      }\n\n      if (nothingResolved && leftUnresolved) {\n        throw new SyntaxError(\n          'Circular reference detected in resolving typed.referTo')\n      }\n    }\n\n    return resolvedFunctions\n  }\n\n  /**\n   * Validate whether any of the function bodies contains a self-reference\n   * usage like `this(...)` or `this.signatures`. This self-referencing is\n   * deprecated since typed-function v3. It has been replaced with\n   * the functions typed.referTo and typed.referToSelf.\n   * @param {Object.<string, function>} signaturesMap\n   */\n  function validateDeprecatedThis (signaturesMap) {\n    // TODO: remove this deprecation warning logic some day (it's introduced in v3)\n\n    // match occurrences like 'this(' and 'this.signatures'\n    const deprecatedThisRegex = /\\bthis(\\(|\\.signatures\\b)/\n\n    Object.keys(signaturesMap).forEach(signature => {\n      const fn = signaturesMap[signature]\n\n      if (deprecatedThisRegex.test(fn.toString())) {\n        throw new SyntaxError('Using `this` to self-reference a function ' +\n          'is deprecated since typed-function@3. ' +\n          'Use typed.referTo and typed.referToSelf instead.')\n      }\n    })\n  }\n\n  /**\n   * Create a typed function\n   * @param {String} name               The name for the typed function\n   * @param {Object.<string, function>} rawSignaturesMap\n   *                                    An object with one or\n   *                                    multiple signatures as key, and the\n   *                                    function corresponding to the\n   *                                    signature as value.\n   * @return {function}  Returns the created typed function.\n   */\n  function createTypedFunction (name, rawSignaturesMap) {\n    typed.createCount++\n\n    if (Object.keys(rawSignaturesMap).length === 0) {\n      throw new SyntaxError('No signatures provided')\n    }\n\n    if (typed.warnAgainstDeprecatedThis) {\n      validateDeprecatedThis(rawSignaturesMap)\n    }\n\n    // Main processing loop for signatures\n    const parsedParams = []\n    const originalFunctions = []\n    const signaturesMap = {}\n    const preliminarySignatures = [] // may have duplicates from conversions\n    let signature\n    for (signature in rawSignaturesMap) {\n      // A) Protect against polluted Object prototype:\n      if (!Object.prototype.hasOwnProperty.call(rawSignaturesMap, signature)) {\n        continue\n      }\n      // B) Parse the signature\n      const params = parseSignature(signature)\n      if (!params) continue\n      // C) Check for conflicts\n      parsedParams.forEach(function (pp) {\n        if (conflicting(pp, params)) {\n          throw new TypeError('Conflicting signatures \"' +\n            stringifyParams(pp) + '\" and \"' +\n            stringifyParams(params) + '\".')\n        }\n      })\n      parsedParams.push(params)\n      // D) Store the provided function and add conversions\n      const functionIndex = originalFunctions.length\n      originalFunctions.push(rawSignaturesMap[signature])\n      const conversionParams = params.map(expandParam)\n      // E) Split the signatures and collect them up\n      let sp\n      for (sp of splitParams(conversionParams)) {\n        const spName = stringifyParams(sp)\n        preliminarySignatures.push(\n          { params: sp, name: spName, fn: functionIndex })\n        if (sp.every(p => !p.hasConversion)) {\n          signaturesMap[spName] = functionIndex\n        }\n      }\n    }\n\n    preliminarySignatures.sort(compareSignatures)\n\n    // Note the forward reference to theTypedFn\n    const resolvedFunctions =\n      resolveReferences(originalFunctions, signaturesMap, theTypedFn)\n\n    // Fill in the proper function for each signature\n    let s\n    for (s in signaturesMap) {\n      if (Object.prototype.hasOwnProperty.call(signaturesMap, s)) {\n        signaturesMap[s] = resolvedFunctions[signaturesMap[s]]\n      }\n    }\n    const signatures = []\n    const internalSignatureMap = new Map() // benchmarks faster than object\n    for (s of preliminarySignatures) {\n      // Note it's only safe to eliminate duplicates like this\n      // _after_ the signature sorting step above; otherwise we might\n      // remove the wrong one.\n      if (!internalSignatureMap.has(s.name)) {\n        s.fn = resolvedFunctions[s.fn]\n        signatures.push(s)\n        internalSignatureMap.set(s.name, s)\n      }\n    }\n\n    // we create a highly optimized checks for the first couple of signatures with max 2 arguments\n    const ok0 = signatures[0] && signatures[0].params.length <= 2 && !hasRestParam(signatures[0].params)\n    const ok1 = signatures[1] && signatures[1].params.length <= 2 && !hasRestParam(signatures[1].params)\n    const ok2 = signatures[2] && signatures[2].params.length <= 2 && !hasRestParam(signatures[2].params)\n    const ok3 = signatures[3] && signatures[3].params.length <= 2 && !hasRestParam(signatures[3].params)\n    const ok4 = signatures[4] && signatures[4].params.length <= 2 && !hasRestParam(signatures[4].params)\n    const ok5 = signatures[5] && signatures[5].params.length <= 2 && !hasRestParam(signatures[5].params)\n    const allOk = ok0 && ok1 && ok2 && ok3 && ok4 && ok5\n\n    // compile the tests\n    for (let i = 0; i < signatures.length; ++i) {\n      signatures[i].test = compileTests(signatures[i].params)\n    }\n\n    const test00 = ok0 ? compileTest(signatures[0].params[0]) : notOk\n    const test10 = ok1 ? compileTest(signatures[1].params[0]) : notOk\n    const test20 = ok2 ? compileTest(signatures[2].params[0]) : notOk\n    const test30 = ok3 ? compileTest(signatures[3].params[0]) : notOk\n    const test40 = ok4 ? compileTest(signatures[4].params[0]) : notOk\n    const test50 = ok5 ? compileTest(signatures[5].params[0]) : notOk\n\n    const test01 = ok0 ? compileTest(signatures[0].params[1]) : notOk\n    const test11 = ok1 ? compileTest(signatures[1].params[1]) : notOk\n    const test21 = ok2 ? compileTest(signatures[2].params[1]) : notOk\n    const test31 = ok3 ? compileTest(signatures[3].params[1]) : notOk\n    const test41 = ok4 ? compileTest(signatures[4].params[1]) : notOk\n    const test51 = ok5 ? compileTest(signatures[5].params[1]) : notOk\n\n    // compile the functions\n    for (let i = 0; i < signatures.length; ++i) {\n      signatures[i].implementation =\n        compileArgsPreprocessing(signatures[i].params, signatures[i].fn)\n    }\n\n    const fn0 = ok0 ? signatures[0].implementation : undef\n    const fn1 = ok1 ? signatures[1].implementation : undef\n    const fn2 = ok2 ? signatures[2].implementation : undef\n    const fn3 = ok3 ? signatures[3].implementation : undef\n    const fn4 = ok4 ? signatures[4].implementation : undef\n    const fn5 = ok5 ? signatures[5].implementation : undef\n\n    const len0 = ok0 ? signatures[0].params.length : -1\n    const len1 = ok1 ? signatures[1].params.length : -1\n    const len2 = ok2 ? signatures[2].params.length : -1\n    const len3 = ok3 ? signatures[3].params.length : -1\n    const len4 = ok4 ? signatures[4].params.length : -1\n    const len5 = ok5 ? signatures[5].params.length : -1\n\n    // simple and generic, but also slow\n    const iStart = allOk ? 6 : 0\n    const iEnd = signatures.length\n    // de-reference ahead for execution speed:\n    const tests = signatures.map(s => s.test)\n    const fns = signatures.map(s => s.implementation)\n    const generic = function generic () {\n      'use strict'\n\n      for (let i = iStart; i < iEnd; i++) {\n        if (tests[i](arguments)) {\n          return fns[i].apply(this, arguments)\n        }\n      }\n\n      return typed.onMismatch(name, arguments, signatures)\n    }\n\n    // create the typed function\n    // fast, specialized version. Falls back to the slower, generic one if needed\n    function theTypedFn (arg0, arg1) {\n      'use strict'\n\n      if (arguments.length === len0 && test00(arg0) && test01(arg1)) { return fn0.apply(this, arguments) }\n      if (arguments.length === len1 && test10(arg0) && test11(arg1)) { return fn1.apply(this, arguments) }\n      if (arguments.length === len2 && test20(arg0) && test21(arg1)) { return fn2.apply(this, arguments) }\n      if (arguments.length === len3 && test30(arg0) && test31(arg1)) { return fn3.apply(this, arguments) }\n      if (arguments.length === len4 && test40(arg0) && test41(arg1)) { return fn4.apply(this, arguments) }\n      if (arguments.length === len5 && test50(arg0) && test51(arg1)) { return fn5.apply(this, arguments) }\n\n      return generic.apply(this, arguments)\n    }\n\n    // attach name the typed function\n    try {\n      Object.defineProperty(theTypedFn, 'name', { value: name })\n    } catch (err) {\n      // old browsers do not support Object.defineProperty and some don't support setting the name property\n      // the function name is not essential for the functioning, it's mostly useful for debugging,\n      // so it's fine to have unnamed functions.\n    }\n\n    // attach signatures to the function.\n    // This property is close to the original collection of signatures\n    // used to create the typed-function, just with unions split:\n    theTypedFn.signatures = signaturesMap\n\n    // Store internal data for functions like resolve, find, etc.\n    // Also serves as the flag that this is a typed-function\n    theTypedFn._typedFunctionData = {\n      signatures,\n      signatureMap: internalSignatureMap\n    }\n\n    return theTypedFn\n  }\n\n  /**\n   * Action to take on mismatch\n   * @param {string} name      Name of function that was attempted to be called\n   * @param {Array} args       Actual arguments to the call\n   * @param {Array} signatures Known signatures of the named typed-function\n   */\n  function _onMismatch (name, args, signatures) {\n    throw createError(name, args, signatures)\n  }\n\n  /**\n   * Return all but the last items of an array or function Arguments\n   * @param {Array | Arguments} arr\n   * @return {Array}\n   */\n  function initial (arr) {\n    return slice(arr, 0, arr.length - 1)\n  }\n\n  /**\n   * return the last item of an array or function Arguments\n   * @param {Array | Arguments} arr\n   * @return {*}\n   */\n  function last (arr) {\n    return arr[arr.length - 1]\n  }\n\n  /**\n   * Slice an array or function Arguments\n   * @param {Array | Arguments | IArguments} arr\n   * @param {number} start\n   * @param {number} [end]\n   * @return {Array}\n   */\n  function slice (arr, start, end) {\n    return Array.prototype.slice.call(arr, start, end)\n  }\n\n  /**\n   * Return the first item from an array for which test(arr[i]) returns true\n   * @param {Array} arr\n   * @param {function} test\n   * @return {* | undefined} Returns the first matching item\n   *                         or undefined when there is no match\n   */\n  function findInArray (arr, test) {\n    for (let i = 0; i < arr.length; i++) {\n      if (test(arr[i])) {\n        return arr[i]\n      }\n    }\n    return undefined\n  }\n\n  /**\n   * Flat map the result invoking a callback for every item in an array.\n   * https://gist.github.com/samgiles/762ee337dff48623e729\n   * @param {Array} arr\n   * @param {function} callback\n   * @return {Array}\n   */\n  function flatMap (arr, callback) {\n    return Array.prototype.concat.apply([], arr.map(callback))\n  }\n\n  /**\n   * Create a reference callback to one or multiple signatures\n   *\n   * Syntax:\n   *\n   *     typed.referTo(signature1, signature2, ..., function callback(fn1, fn2, ...) {\n   *       // ...\n   *     })\n   *\n   * @returns {{referTo: {references: string[], callback}}}\n   */\n  function referTo () {\n    const references =\n      initial(arguments).map(s => stringifyParams(parseSignature(s)))\n    const callback = last(arguments)\n\n    if (typeof callback !== 'function') {\n      throw new TypeError('Callback function expected as last argument')\n    }\n\n    return makeReferTo(references, callback)\n  }\n\n  function makeReferTo (references, callback) {\n    return { referTo: { references, callback } }\n  }\n\n  /**\n   * Create a reference callback to the typed-function itself\n   *\n   * @param {(self: function) => function} callback\n   * @returns {{referToSelf: { callback: function }}}\n   */\n  function referToSelf (callback) {\n    if (typeof callback !== 'function') {\n      throw new TypeError('Callback function expected as first argument')\n    }\n\n    return { referToSelf: { callback } }\n  }\n\n  /**\n   * Test whether something is a referTo object, holding a list with reference\n   * signatures and a callback.\n   *\n   * @param {Object | function} objectOrFn\n   * @returns {boolean}\n   */\n  function isReferTo (objectOrFn) {\n    return objectOrFn &&\n      typeof objectOrFn.referTo === 'object' &&\n      Array.isArray(objectOrFn.referTo.references) &&\n      typeof objectOrFn.referTo.callback === 'function'\n  }\n\n  /**\n   * Test whether something is a referToSelf object, holding a callback where\n   * to pass `self`.\n   *\n   * @param {Object | function} objectOrFn\n   * @returns {boolean}\n   */\n  function isReferToSelf (objectOrFn) {\n    return objectOrFn &&\n      typeof objectOrFn.referToSelf === 'object' &&\n      typeof objectOrFn.referToSelf.callback === 'function'\n  }\n\n  /**\n   * Check if name is (A) new, (B) a match, or (C) a mismatch; and throw\n   * an error in case (C).\n   *\n   * @param { string | undefined } nameSoFar\n   * @param { string | undefined } newName\n   * @returns { string } updated name\n   */\n  function checkName (nameSoFar, newName) {\n    if (!nameSoFar) {\n      return newName\n    }\n    if (newName && newName !== nameSoFar) {\n      const err = new Error('Function names do not match (expected: ' +\n        nameSoFar + ', actual: ' + newName + ')')\n      err.data = { actual: newName, expected: nameSoFar }\n      throw err\n    }\n    return nameSoFar\n  }\n\n  /**\n   * Retrieve the implied name from an object with signature keys\n   * and function values, checking whether all value names match\n   *\n   * @param { {string: function} } obj\n   */\n  function getObjectName (obj) {\n    let name\n    for (const key in obj) {\n      // Only pay attention to own properties, and only if their values\n      // are typed functions or functions with a signature property\n      if (Object.prototype.hasOwnProperty.call(obj, key) &&\n          (isTypedFunction(obj[key]) ||\n           typeof obj[key].signature === 'string')) {\n        name = checkName(name, obj[key].name)\n      }\n    }\n    return name\n  }\n\n  /**\n   * Copy all of the signatures from the second argument into the first,\n   * which is modified by side effect, checking for conflicts\n   *\n   * @param {Object.<string, function|typed-reference>} dest\n   * @param {Object.<string, function|typed-reference>} source\n   */\n  function mergeSignatures (dest, source) {\n    let key\n    for (key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        if (key in dest) {\n          if (source[key] !== dest[key]) {\n            const err = new Error('Signature \"' + key + '\" is defined twice')\n            err.data = {\n              signature: key,\n              sourceFunction: source[key],\n              destFunction: dest[key]\n            }\n            throw err\n          }\n          // else: both signatures point to the same function, that's fine\n        }\n        dest[key] = source[key]\n      }\n    }\n  }\n\n  const saveTyped = typed\n\n  /**\n   * Originally the main function was a typed function itself, but then\n   * it might not be able to generate error messages if the client\n   * replaced the type system with different names.\n   *\n   * Main entry: typed([name], functions/objects with signatures...)\n   *\n   * Assembles and returns a new typed-function from the given items\n   * that provide signatures and implementations, each of which may be\n   * * a plain object mapping (string) signatures to implementing functions,\n   * * a previously constructed typed function, or\n   * * any other single function with a string-valued property `signature`.\n\n   * The name of the resulting typed-function will be given by the\n   * string-valued name argument if present, or if not, by the name\n   * of any of the arguments that have one, as long as any that do are\n   * consistent with each other. If no name is specified, the name will be\n   * an empty string.\n   *\n   * @param {string} maybeName [optional]\n   * @param {(function|object)[]} signature providers\n   * @returns {typed-function}\n   */\n  typed = function (maybeName) {\n    const named = typeof maybeName === 'string'\n    const start = named ? 1 : 0\n    let name = named ? maybeName : ''\n    const allSignatures = {}\n    for (let i = start; i < arguments.length; ++i) {\n      const item = arguments[i]\n      let theseSignatures = {}\n      let thisName\n      if (typeof item === 'function') {\n        thisName = item.name\n        if (typeof item.signature === 'string') {\n          // Case 1: Ordinary function with a string 'signature' property\n          theseSignatures[item.signature] = item\n        } else if (isTypedFunction(item)) {\n          // Case 2: Existing typed function\n          theseSignatures = item.signatures\n        }\n      } else if (isPlainObject(item)) {\n        // Case 3: Plain object, assume keys = signatures, values = functions\n        theseSignatures = item\n        if (!named) {\n          thisName = getObjectName(item)\n        }\n      }\n\n      if (Object.keys(theseSignatures).length === 0) {\n        const err = new TypeError(\n          'Argument to \\'typed\\' at index ' + i + ' is not a (typed) function, ' +\n          'nor an object with signatures as keys and functions as values.')\n        err.data = { index: i, argument: item }\n        throw err\n      }\n\n      if (!named) {\n        name = checkName(name, thisName)\n      }\n      mergeSignatures(allSignatures, theseSignatures)\n    }\n\n    return createTypedFunction(name || '', allSignatures)\n  }\n\n  typed.create = create\n  typed.createCount = saveTyped.createCount\n  typed.onMismatch = _onMismatch\n  typed.throwMismatchError = _onMismatch\n  typed.createError = createError\n  typed.clear = clear\n  typed.clearConversions = clearConversions\n  typed.addTypes = addTypes\n  typed._findType = findType // For unit testing only\n  typed.referTo = referTo\n  typed.referToSelf = referToSelf\n  typed.convert = convert\n  typed.findSignature = findSignature\n  typed.find = find\n  typed.isTypedFunction = isTypedFunction\n  typed.warnAgainstDeprecatedThis = true\n\n  /**\n   * add a type (convenience wrapper for typed.addTypes)\n   * @param {{name: string, test: function}} type\n   * @param {boolean} [beforeObjectTest=true]\n   *                          If true, the new test will be inserted before\n   *                          the test with name 'Object' (if any), since\n   *                          tests for Object match Array and classes too.\n   */\n  typed.addType = function (type, beforeObjectTest) {\n    let before = 'any'\n    if (beforeObjectTest !== false && typeMap.has('Object')) {\n      before = 'Object'\n    }\n    typed.addTypes([type], before)\n  }\n\n  /**\n   * Verify that the ConversionDef conversion has a valid format.\n   *\n   * @param {conversionDef} conversion\n   * @return {void}\n   * @throws {TypeError|SyntaxError}\n   */\n  function _validateConversion (conversion) {\n    if (!conversion ||\n        typeof conversion.from !== 'string' ||\n        typeof conversion.to !== 'string' ||\n        typeof conversion.convert !== 'function') {\n      throw new TypeError('Object with properties {from: string, to: string, convert: function} expected')\n    }\n    if (conversion.to === conversion.from) {\n      throw new SyntaxError(\n        'Illegal to define conversion from \"' + conversion.from +\n        '\" to itself.')\n    }\n  }\n\n  /**\n   * Add a conversion\n   *\n   * @param {ConversionDef} conversion\n   * @returns {void}\n   * @throws {TypeError}\n   */\n  typed.addConversion = function (conversion) {\n    _validateConversion(conversion)\n\n    const to = findType(conversion.to)\n    if (to.conversionsTo.every(function (other) {\n      return other.from !== conversion.from\n    })) {\n      to.conversionsTo.push({\n        from: conversion.from,\n        convert: conversion.convert,\n        index: nConversions++\n      })\n    } else {\n      throw new Error(\n        'There is already a conversion from \"' + conversion.from + '\" to \"' +\n        to.name + '\"')\n    }\n  }\n\n  /**\n   * Convenience wrapper to call addConversion on each conversion in a list.\n   *\n   @param {ConversionDef[]} conversions\n   @returns {void}\n   @throws {TypeError}\n   */\n  typed.addConversions = function (conversions) {\n    conversions.forEach(typed.addConversion)\n  }\n\n  /**\n   * Remove the specified conversion. The format is the same as for\n   * addConversion, and the convert function must match or an error\n   * is thrown.\n   *\n   * @param {{from: string, to: string, convert: function}} conversion\n   * @returns {void}\n   * @throws {TypeError|SyntaxError|Error}\n   */\n  typed.removeConversion = function (conversion) {\n    _validateConversion(conversion)\n    const to = findType(conversion.to)\n    const existingConversion =\n      findInArray(to.conversionsTo, c => (c.from === conversion.from))\n    if (!existingConversion) {\n      throw new Error(\n        'Attempt to remove nonexistent conversion from ' + conversion.from +\n        ' to ' + conversion.to)\n    }\n    if (existingConversion.convert !== conversion.convert) {\n      throw new Error(\n        'Conversion to remove does not match existing conversion')\n    }\n    const index = to.conversionsTo.indexOf(existingConversion)\n    to.conversionsTo.splice(index, 1)\n  }\n\n  /**\n   * Produce the specific signature that a typed function\n   * will execute on the given arguments. Here, a \"signature\" is an\n   * object with properties 'params', 'test', 'fn', and 'implementation'.\n   * This last property is a function that converts params as necessary\n   * and then calls 'fn'. Returns null if there is no matching signature.\n   * @param {typed-function} tf\n   * @param {any[]} argList\n   * @returns {{params: string, test: function, fn: function, implementation: function}}\n   */\n  typed.resolve = function (tf, argList) {\n    if (!isTypedFunction(tf)) {\n      throw new TypeError(NOT_TYPED_FUNCTION)\n    }\n    const sigs = tf._typedFunctionData.signatures\n    for (let i = 0; i < sigs.length; ++i) {\n      if (sigs[i].test(argList)) {\n        return sigs[i]\n      }\n    }\n    return null\n  }\n\n  return typed\n}\n\nexport default create()\n"],"mappings":"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"}